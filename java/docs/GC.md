# Java GC
JVM(HotSpot JVM)提供的的垃圾回收机制。Java的内存管理实际上就是对象的管理，其中包括对象的分配和释放。分配是在创建对象的时候完成的。
释放过程则由虚拟机自己完成，开发人员调用`System.gc();`是无法做到即时的回收的。

## 回收算法

## 引用计数法(Reference Counting)
统计实例对象的引用次数，每有一个对象使用了实例对象的引用，该实例对象的引用计数自动累加。
当没有对象引用了该实例对象，则该实例对象的引用计数为0。则该对象不可能在被使用。当然该方法
无法解决循环引用的场景。估JVM没有采用才算法。

### 缺点
  - 频繁操作对象时，增加系统的消耗
  - 无法解决循环引用场景

## 标记-清除算法(Mark-Sweep)
标记清除顾名思义即为两个阶段：标记阶段、清除阶段。
  - 标记阶段：首先通过根节点，标记所有从根节点开始的可达对象。故未被标记的对象就是未被引用的垃圾对象。
  - 清除阶段：清除所有未被标记的对象。
  
### 缺点
  - 回收后的空间不连续，产生空间碎片
  - 大对象分配时，比内存空间连续的效率低

## 复制算法(Copying)
将内存空间分为两块，每次只使用其中一块。在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中.
之后，清除正在使用的内存中的所有对象，交换两个内存的角色。如果系统中垃圾对象多，需要复制的存活对象数量就会相对较少。
因此，复制算法的效率是很高的，而且新的内存空间中可以保证是没有内存碎片的。

### 缺点
  - 系统内存折半
  - 存活对象较多时，效率不能保证

## 标记-整理算法(Mark-Compact)
对标记清除法做了改进：标记阶段，整理阶段，清除阶段
  - 标记阶段：同标记清除算法
  - 整理阶段：标记过的对象集中放到一起，确定开始和结束地址。
  - 清除阶段：同标记清除算法
  
### 缺点
  - 压缩阶段增加性能消耗，尤其是标记对象过多时。

## 增量算法(Incremental Collecting)
垃圾收集线程每次只处理一小段内存区域，反复的与应用程序进行切换从而完成对整个内存区域的回收。依次减少垃圾收集时造成系统停顿的问题。

### 缺点
  - 增加线程切换和上下文转换的消耗
  - 减少系统的吞吐量

## 分代(Generational Collecting)
将内存区间根据对象的特点进行分区，根据不同的分区使用不同的回收算法。

## Java GC的对象
采用GCRoots的方法。从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。

## Java GC的流程

### Eden区满时候
 此时触发Minor GC，使用的是标记-整理算法。操作流程如下
  1. Eden区和From区中还被引用的对象会被移到To区(第一次时，JVM会从两个Survivor区随机选出From区和To区)
  1. 复制过程中To已满的，个别大对象和部分From对象会被复制到Old区

### Old区满时
 此时触发Full GC，Full GC是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC。
其包含两个GC过程，Minor GC和Major GC。其处理流程如下：
  1. 触发Minor GC
  2. 按照标记，整理复制标记对象，清除为标记对象


## Java GC的类型

### Minor GC
清理年轻代。

年轻代有一个新生代(Eden)和两个幸存区（Survivor,默认比例为8:1，Survivor，一个叫From ,一个叫To），
首先将对象放入Eden区，如果空间不足就向其中一个Survivor区上放，如果仍然放不下，就会引发一次在新生代
的minor GC，将存活的对象放入另一个survivor去中，然后清空Eden和之前的那个Survivor的内存.
在minor GC过程中，如果发现仍然有放不下的对象，就将这些对象放入老年代内存中。

### Full GC

当每次执行minor GC的时候，应该对要晋升到老年代的对象进行分析。如果这些需要复制到老年区的老年对象的大小，
超过了老年区的剩余大小，那么执行一次Full GC以尽可能的获得老年区的空间。

### Major GC
清理老年代，采用标记-整理算法
